library("crch")                                                  # регрессия с усечением

library("hpa")                                                   # моменты усеченного нормального распределения

# Симулируем данные
library("mvtnorm")
# Подключим необходимые библиотеки
library("titanic")                                               # пакет, содержащий датафрейм с
library("glmx")                                                  # пакет, позволяющий оценивать пробит
library("lmtest")                                                # дополнительные тесты
library("numDeriv")                                              # численное дифференцирование
library("sampleSelection")                                       # встроенный датафрейм для
library("GJRM")                                                  # система бинарных уравнений

# Отключим scientific notation
options(scipen = 999)

# Подключим встроенный датафрейм, содержащий информацию
# о характеристиках американских женщин и их трудовом
# статусе в 1975-1976 годах
data(Mroz87)
# Для тех, у кого не считывается встроенный датафрейм
library("readxl")                                                                          # предварительно установите пакет
Mroz87 <- read_excel("C:\\Users\\yaava\\Desktop\\HW2\\Mroz87.xlsx") # укажите путь к файлу                                                                                          # на своем компьютере
h <- na.omit(as.data.frame(Mroz87))
# Краткое описание:
help(Mroz87)


#---------------------------------------------------
# 2.1. Оцените Тобит модель, предварительно записав максимизируемую функцию правдоподобия. 
# Результат представьте в форме таблицы (можно, например, использовать выдачу из stata, R или python).
#---------------------------------------------------

# Оценим параметры модели Тобина
tr <- 0                                              # точка усечения слева
rtr <- 11                                            # точка усечения справа
model_tb <- crch(wage ~ age + educ + hushrs,         # формула
                 data = h,                           # данные                       
                 left = tr,                          # нижнее (левое) усечение
                 right = rtr,                        # верхнее (правое) усечение
                 truncated = FALSE,                  # модель Тобина
                 dist = "gaussian")                  # распределение случайной ошибки
summary(model_tb)                                    # посмотрим результат
est_tb <- coef(model_tb)                             # достанем оценки
coef_tb <- est_tb[-length(est_tb)]                   # оценки регрессионныхкоэффициентов
sigma_tb <- exp(est_tb[length(est_tb)])              # достаем оценку стандартного отклонения


#---------------------------------------------------
# 2.4. Для индивида с произвольными характеристиками 
# укажите (предварительно записав используемые для расчетов формулы): 
#---------------------------------------------------

# Рассчитаем оценку безусловного математического
# расходов для конкретного индивида
Anna <- data.frame(age = 30,
                  educ = 15,
                  hushrs = 7)

# Предскажем ожидаемые расходы без 
# учета цензурирования, то есть E(wage*)
wage_est <- predict(model_tb, 
                     newdata = Anna)

# Оценим вероятность того, что Анна
# зарабатывает больше 0
prob_est <- 1 - pnorm((tr - wage_est) / sigma_tb)

# Оценим вероятность того, что Анна
# зарабатывает меньше 11
prob_est_r <- pnorm((rtr - wage_est) / sigma_tb)

# Предскажем условное математическое
# ожидание доходов
# вычислим E(e | wage* >= tr_left)
# с помощью функции
epsilon_E <- truncatedNormalMoment(k = 1,                      # момент
                                   x_lower = tr - wage_est,    # нижнее усечение
                                   x_upper = rtr - wage_est,   # верхние усечение
                                   mean = 0,                   # математическое ожидание
                                   sd = sigma_tb)              # стандартное отклонение

# посчитаем E(wage* | tr_left <= wage* <= tr_right)
wage_est_cond <- wage_est + epsilon_E
# рассчитаем E(wage)
wage_est_cens <- prob_est * wage_est_cond + (1 - prob_est) * tr + (1 - prob_est_r) * rtr

a <- (tr - wage_est) / sigma_tb
b <- (rtr - wage_est) / sigma_tb
lambda <- (dnorm(a) - dnorm(b)) / (pnorm(b) - pnorm(a))

#---------------------------------------------------
# 2.5. Для индивида с произвольными характеристиками рассчитайте предельный эффект любой переменной (не дамми), 
# входящей линейно (предварительно записав используемые для расчетов формулы) на:
#---------------------------------------------------

# Рассмотрим предельные эффекты на
# E(wage* | tr_left <= wage* <= tr_right)
ME_cond <- coef_tb * (1 - lambda * lambda - (a * dnorm(a) - b * dnorm(b))/(pnorm(b) - pnorm(a)))
# E(wage)
ME_cens <- coef_tb * prob_est
# Вероятность цензурирования
ME_prob <- - coef_tb / sigma_tb * (1 - (dnorm(a)))

#---------------------------------------------------
#3.1. Оцените модель Хекмана с помощью метода максимального правдоподобия, 
# предварительно записав максимизируемую функцию правдоподобия и указав независимые 
# переменные в уравнении занятости, которое должно иметь по крайней мере одну переменную, 
# не входящую в уравнение зарплаты. Результат представьте в форме таблицы 
# (можно, например, использовать выдачу из stata, R или python).
#---------------------------------------------------

# метода Хекмана, основанный на ММП
model_mle <- selection(                              
  selection = lfp ~ age + kids618 + huswage,                     # уравнение отбора
  outcome = wage ~ age + educ + hushrs,                   # основное уравнение
  data = h,                                          # данные
  method = "ml")                                     # метод расчета ММП
summary(model_mle)                                   # результат оценивания
coef_mle <- coef(model_mle, part = "outcome")        # сохраним оценки коэффициентов
rho_mle <- model_mle$estimate["rho"]                 # оценка корреляции между
# случайными ошибками
sigma_mle <- model_mle$estimate["sigma"]             # стандартное отклонение

#---------------------------------------------------
# 3.3. Воспользуйтесь методом Хекмана, основанным на двухшаговой процедуре и сравните оценки, 
# с полученными с использованием метода Хекмана, основанном на методе максимального правдоподобия. 
# Опишите относительные преимущества и недостатки обоих методов.
#---------------------------------------------------

# метода Хекмана, основанного на
# двухшаговой процедуре
model_2st <- selection(                              
  selection = lfp ~ age + kids618 + huswage,                     
  outcome = wage ~ age + educ + hushrs,                   
  data = h,                                          
  method = "2step")                                  # метод расчета двухшаговая процедура
summary(model_2st)                                   # результат оценивания
coef_2st <- coef(model_2st, part = "outcome")        # сохраним оценки коэффициентов

#---------------------------------------------------
# 3.5. В любой из двух оцененных в данном разделе моделей для индивида 
# с произвольными характеристиками рассчитайте (предварительно записав формулу):
#---------------------------------------------------

# Произвольный индивид
Anna <- data.frame("age" = 30,
                   "educ" = 15,
                   "hushrs" = 7,
                   "kids618" = 3,
                   "huswage" = 8)

# Рассчитаем оценку условного математического 
# ожидания зависимой переменной основного уравнения,
# то есть E(y*|z)
cost_cond <- predict(model_mle, 
                     newdata = Anna, 
                     part = "outcome",                   # для основного уравнения
                     type = "conditional")               # условные предсказания 
cost_cond[1]                                             # E(y*|z = 0)
cost_cond[2]                                             # E(y*|z = 1)

# оценим линейный индекс
cat_li <- predict(model_mle, 
                  newdata = Anna, 
                  part = "selection",                    # для уравнения отбора
                  type = "link")                         # предсказываем линейный индекс

lambda_est_1 <- dnorm(cat_li) / pnorm(cat_li)            # оценка отношения Миллса
lambda_est_2 <- dnorm(cat_li) / pnorm(-cat_li)

coef_s_est <- coef(model_mle)[1:4]

age_ME <- coef_mle["age"] - rho_mle * sigma_mle *
  (cat_li * lambda_est_1 +
     lambda_est_1 ^ 2) *
  coef_s_est["age"]

age_ME <- coef_mle["age"] - rho_mle * sigma_mle *
  (cat_li * lambda_est_2 -
     lambda_est_2 ^ 2) *
  coef_s_est["age"]